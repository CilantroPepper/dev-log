import{_ as s,o as a,c as n,U as l}from"./chunks/framework.c270b6c9.js";const o="/assets/stack.e0f8eb6b.png",p="/assets/tabbar.0ebc51d1.png",e="/assets/menu.ef923e86.png",h=JSON.parse('{"title":"工程指南","description":"","frontmatter":{},"headers":[],"relativePath":"guide.md","filePath":"guide.md"}'),t={name:"guide.md"},c=l(`<h1 id="工程指南" tabindex="-1">工程指南 <a class="header-anchor" href="#工程指南" aria-label="Permalink to &quot;工程指南&quot;">​</a></h1><p>本指南旨在介绍Cream Client Responsive App（以下简称CC）的项目结构和开发指引。</p><blockquote><p>本文档适合初次上手CC响应式应用的新人阅读。</p></blockquote><h2 id="项目概述" tabindex="-1">项目概述 <a class="header-anchor" href="#项目概述" aria-label="Permalink to &quot;项目概述&quot;">​</a></h2><p>CC为计算机学院综测系统中的C端子系统，主要针对的使用群体为<strong>学生</strong>，在整个综测评审过程中，主要用于学生查看信息、填报材料的环节。考虑到B端系统对移动端的适配性较低，CC更加注重于移动端和桌面端的双端全量支持，也即双端的<strong>响应式布局</strong>。</p><p>在此介绍两个重要概念：<strong>WAP端和PC端</strong>：</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>WAP端：窄屏设备，也即移动端，当前配置下默认为屏幕宽度小于800px的设备</p><p>PC端：宽屏设备，也即桌面端，当前配置下默认为屏幕宽度大于等于800px的设备</p></div><p>换言之，WAP端和PC端应该实现完全相同的业务，但在表现形式上应针对宽屏和窄屏设备做出不同的兼容。例如： 宽屏设备在横向空间可以容纳更多的分栏，故可以对卡片等组件使用<strong>横向flex</strong>布局，而窄屏设备横向空间不足，在容纳相同的卡片时应该采用<strong>纵向flex</strong>布局。</p><p>在<a href="#深入响应式布局">深入响应式布局</a>中，还会详细介绍响应式布局实现的解决方案，以及CC现有基本框架的实现实例。</p><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>特别地，在对WAP端实现完全兼容的情况下，也必须格外注意PC端的使用体验，因为综测系统的特殊性，在很大可能下，用户是通过PC设备访问的。</p></div><p>CC基于Web构建，用户通过Browser(也就是浏览器)使用CC。得益于Web技术的飞速发展，现如今已经有非常多开箱即用的技术栈可以帮助我们进行敏捷开发，而基于各方面考虑，CC的技术选型为：<strong>Vite + Vue3 + TypeScript + SCSS + ElementPlus + Pinia + VueRouter</strong>，下面将会详细介绍各个技术栈如何帮助我们更便捷地构建一个优秀的产品。</p><ol><li><p><strong>Vite</strong></p><p>Vite是一个现代的前端开发和构建工具，也是Vue3的官方推荐工具链中的构建工具，它开箱即用地提供极速启动服务、热重载技术、TS天然支持等等好处。</p><blockquote><p>Vite 官方文档：<a href="https://cn.vitejs.dev/" target="_blank" rel="noreferrer">https://cn.vitejs.dev/</a></p></blockquote></li><li><p><strong>Vue3</strong></p><p>Vue是中文生态中最火爆的Web前端框架，本项目基于Vue3快速构建SPA(Single Page Application 单页应用)。</p><blockquote><p>Vue3官方文档：<a href="https://cn.vuejs.org/" target="_blank" rel="noreferrer">https://cn.vuejs.org/</a></p></blockquote><div class="info custom-block"><p class="custom-block-title">INFO</p><p>如果你是第一次接触SPA(单页应用)的概念，请不要被迷惑了，单页是指打包构建完只会有一个HTML文件，而所有页面切换、路由等等的操作都被JavaScript接手了，并不是CC只有一个页面的意思！CC借助Vite、Vue和VueRouter的能力实现了非常独特的路由管理机制，后面也会详细介绍CC独具一格的路由设计。</p></div><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>你应该着重关注Vue3的<strong>组合式API</strong>，这在CC中大量使用，甚至于我们不会使用任何非组合式API，也就是选项式API不是CC中的最佳实践！</p><p>特别地，你需要学会如何使用<strong>setup语法糖</strong>，你将会在编码规范中看到setup语法糖是编写Vue组件的第一范式！！</p><p>同样重要的还有<strong>hook</strong>，你应该学会利用Vue的响应式原理编写或使用自定义hook。</p></div></li><li><p><strong>TypeScript</strong></p><p>CC全量使用TypeScript！！TS的类型特性将帮助CC搭建更加健壮且更易维护的模块，任何人为编写的JS都是不被允许的。包括Vue组件在内，CC所有的模块都基于TypeScript编写。</p><blockquote><p>TypeScript参考文档：<a href="https://www.tslang.cn/docs/home.html" target="_blank" rel="noreferrer">https://www.tslang.cn/docs/home.html</a></p></blockquote></li><li><p><strong>SCSS</strong></p><p>使用这种CSS扩展语言可以帮助我们减少CSS代码量，你不需要对SCSS掌握的很深入，只需要学会利用其嵌套CSS的特性、SCSS变量的特性即可。剩下的，就是深入原生CSS，着重掌握<strong>flex</strong>布局（纵向或横向）。</p><div class="tip custom-block"><p class="custom-block-title">💡最佳实践</p><p>在CC中，所有自定义样式的第一范式就是：<strong>使用flex布局</strong>。</p></div></li><li><p><strong>ElementPlus</strong></p><p>ElementPlus 是基于Vue3构建的优秀的组件库，开箱即用地提供了非常多实用组件，CC已经对ElementPlus进行了一定的客制化且进行了按需引入优化，开发者只需要按照ElementPlus文档自由使用其组件即可。你也可以在运行项目后进入 <code>http://localhost:81/s/guide/</code> 查看组件示例，该部分的源码在 <code>/src/views/guide/index.vue</code> 中。</p><blockquote><p>ElementPlus官方文档：<a href="https://element-plus.org/zh-CN/component/button.html" target="_blank" rel="noreferrer">https://element-plus.org/zh-CN/component/button.html</a></p></blockquote></li><li><p><strong>Pinia</strong></p><p>一个Vue3官方推荐的、非常优雅、深度TS类型支持的Vue3状态库。什么是状态库？你可以理解为放着全局变量的地方，且这些变量是<strong>响应式</strong>的。也就是我们可以非常简便且没有任何负担或者副作用地引用全局状态库里的东西，这在一个对象需要被不同层级的很多组件引用时非常有用，它能保证所有组件的引用值保持同步。</p><blockquote><p>Pinia官方文档：<a href="https://pinia.vuejs.org/zh/" target="_blank" rel="noreferrer">https://pinia.vuejs.org/zh/</a></p></blockquote><div class="info custom-block"><p class="custom-block-title">INFO</p><p>如果响应式变量这个词比较晦涩难懂，那可以理解为：有一个变量B引用了某个<strong>变量A</strong>，而在另一个地方改变了这个变量A，那么不需要手动更改变量B，变量B的值会自动更新，那么这个<strong>变量A</strong>就是响应式变量。响应式变量的值一旦改变，任何依赖于这个响应式变量的对象都会自动重新计算得到新的值。</p><p>关于响应式，你可以查看Vue3官方文档中的深入阐释。</p></div></li><li><p><strong>VueRouter</strong></p><p>同样是Vue3官方推荐的路由管理库，但是作为关注业务核心的开发人员，你无需过多在意CC在架构上对VueRouter进行的配置细节，你只需要知道CC总体上拥有两大路由：TabBar路由和Stack路由，在后面<a href="#深入路由管理">深入路由管理</a>中，你将会看到对这两个名词最具体的介绍。</p><blockquote><p>VueRouter官方文档：<a href="https://router.vuejs.org/zh/" target="_blank" rel="noreferrer">https://router.vuejs.org/zh/</a></p></blockquote></li></ol><p>除此之外，CC还引入了 Animate.css 作为基础的动画库，如果有任何设计需要，也可以直接使用 Animate.css 提供的动画效果。具体使用方法请见官方文档：<a href="https://animate.style/" target="_blank" rel="noreferrer">https://animate.style/</a></p><h2 id="环境及依赖" tabindex="-1">环境及依赖 <a class="header-anchor" href="#环境及依赖" aria-label="Permalink to &quot;环境及依赖&quot;">​</a></h2><h3 id="sdk依赖" tabindex="-1">SDK依赖 <a class="header-anchor" href="#sdk依赖" aria-label="Permalink to &quot;SDK依赖&quot;">​</a></h3><ul><li>Node.js v18.x+</li><li>npm v9.0+</li></ul><h3 id="npm依赖下载" tabindex="-1">npm依赖下载 <a class="header-anchor" href="#npm依赖下载" aria-label="Permalink to &quot;npm依赖下载&quot;">​</a></h3><p>进入项目目录后，终端输入：</p><div class="language-shell"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">npm</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">install</span></span></code></pre></div><h3 id="dev环境运行" tabindex="-1">Dev环境运行 <a class="header-anchor" href="#dev环境运行" aria-label="Permalink to &quot;Dev环境运行&quot;">​</a></h3><p>项目目录终端输入：</p><div class="language-shell"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">npm</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">run</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">dev</span></span></code></pre></div><p>在Dev运行环境下，Vite提供了非常便捷的热更新功能，即更改代码保存后会立刻反映到运行结果上。</p><h3 id="production环境打包" tabindex="-1">Production环境打包 <a class="header-anchor" href="#production环境打包" aria-label="Permalink to &quot;Production环境打包&quot;">​</a></h3><p>项目目录终端输入：</p><div class="language-shell"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">npm</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">run</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">build</span></span></code></pre></div><h3 id="环境变量" tabindex="-1">环境变量 <a class="header-anchor" href="#环境变量" aria-label="Permalink to &quot;环境变量&quot;">​</a></h3><p>注意到项目目录中有两个 <code>.env</code> 文件，它们标识了不同环境下应该引入到项目中的环境变量。这种引入是Vite提供的，无需手动引入，因而如果你想添加额外的环境变量只需在对应环境下的 <code>.env</code> 文件进行更改，然后再在 <code>src/config.ts</code> 文件中进行全局引用即可。</p><ul><li><p><code>.env.development</code>：在development环境下会被引入项目</p></li><li><p><code>.env.production</code>：在production环境下（打包时）会被引入项目</p></li><li><p><code>src/config.ts</code>引用环境变量的方式：可以学习已有的引用：</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> config </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">app</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">      </span><span style="color:#676E95;font-style:italic;">// ...</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#F07178;">xxx</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">meta</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">env</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">VITE_XXX</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#89DDFF;">      </span><span style="color:#676E95;font-style:italic;">// ...</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// ...</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>然后在其他需要引用这个环境变量的地方，就只需要引用 <code>config.app.xxx</code></p></li></ul><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>自定义的环境变量必须是 <code>VITE_</code> 开头的！！具体细节请参见Vite官方文档</p></div><h2 id="项目结构" tabindex="-1">项目结构 <a class="header-anchor" href="#项目结构" aria-label="Permalink to &quot;项目结构&quot;">​</a></h2><p>项目结构树及其重要部分解释</p><div class="language-shell"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">c-app</span></span>
<span class="line"><span style="color:#FFCB6B;">├─</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">.env.development</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">-</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">开发环境下的环境变量</span></span>
<span class="line"><span style="color:#FFCB6B;">├─</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">.env.production</span><span style="color:#A6ACCD;">  </span><span style="color:#C3E88D;">-</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">生产环境下的环境变量</span></span>
<span class="line"><span style="color:#FFCB6B;">├─</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">index.html</span><span style="color:#A6ACCD;">       </span><span style="color:#C3E88D;">-</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">根主页，可以不管</span></span>
<span class="line"><span style="color:#FFCB6B;">├─</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">package.json</span><span style="color:#A6ACCD;">     </span><span style="color:#C3E88D;">-</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">依赖记录、运行脚本等</span></span>
<span class="line"><span style="color:#FFCB6B;">├─</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">public</span><span style="color:#A6ACCD;">           </span><span style="color:#C3E88D;">-</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">公开静态资源目录，可以不管</span></span>
<span class="line"><span style="color:#FFCB6B;">├─</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">src</span><span style="color:#A6ACCD;">              </span><span style="color:#C3E88D;">-</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">核心资源</span></span>
<span class="line"><span style="color:#FFCB6B;">│</span><span style="color:#A6ACCD;">  </span><span style="color:#C3E88D;">├─</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">apis</span><span style="color:#A6ACCD;">          </span><span style="color:#C3E88D;">-</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">所有API（接口）调用，目前后端还未给出接口所以是空目录</span></span>
<span class="line"><span style="color:#FFCB6B;">│</span><span style="color:#A6ACCD;">  </span><span style="color:#C3E88D;">├─</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">App.vue</span><span style="color:#A6ACCD;">       </span><span style="color:#C3E88D;">-</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">Vue根组件，可以不管</span></span>
<span class="line"><span style="color:#FFCB6B;">│</span><span style="color:#A6ACCD;">  </span><span style="color:#C3E88D;">├─</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">assets</span><span style="color:#A6ACCD;">        </span><span style="color:#C3E88D;">-</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">静态资源目录，建议将所有全局静态资源都放在这里</span></span>
<span class="line"><span style="color:#FFCB6B;">│</span><span style="color:#A6ACCD;">  </span><span style="color:#C3E88D;">│</span><span style="color:#A6ACCD;">  </span><span style="color:#C3E88D;">├─</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">images</span><span style="color:#A6ACCD;">     </span><span style="color:#C3E88D;">-</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">静态图片目录</span></span>
<span class="line"><span style="color:#FFCB6B;">│</span><span style="color:#A6ACCD;">  </span><span style="color:#C3E88D;">│</span><span style="color:#A6ACCD;">  </span><span style="color:#C3E88D;">└─</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">styles</span><span style="color:#A6ACCD;">     </span><span style="color:#C3E88D;">-</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">全局样式目录</span></span>
<span class="line"><span style="color:#FFCB6B;">│</span><span style="color:#A6ACCD;">  </span><span style="color:#C3E88D;">├─</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">components</span><span style="color:#A6ACCD;">    </span><span style="color:#C3E88D;">-</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">封装的全局组件</span></span>
<span class="line"><span style="color:#FFCB6B;">│</span><span style="color:#A6ACCD;">  </span><span style="color:#C3E88D;">├─</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">config.ts</span><span style="color:#A6ACCD;">     </span><span style="color:#C3E88D;">-</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">核心配置文件</span></span>
<span class="line"><span style="color:#FFCB6B;">│</span><span style="color:#A6ACCD;">  </span><span style="color:#C3E88D;">├─</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">layouts</span><span style="color:#A6ACCD;">       </span><span style="color:#C3E88D;">-</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">基础响应式布局目录，业务开发中可以不管</span></span>
<span class="line"><span style="color:#FFCB6B;">│</span><span style="color:#A6ACCD;">  </span><span style="color:#C3E88D;">├─</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">main.ts</span><span style="color:#A6ACCD;">       </span><span style="color:#C3E88D;">-</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">入口文件，可以不管</span></span>
<span class="line"><span style="color:#FFCB6B;">│</span><span style="color:#A6ACCD;">  </span><span style="color:#C3E88D;">├─</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">tab.ts</span><span style="color:#A6ACCD;">        </span><span style="color:#C3E88D;">-</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">Tab页配置文件</span></span>
<span class="line"><span style="color:#FFCB6B;">│</span><span style="color:#A6ACCD;">  </span><span style="color:#C3E88D;">├─</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">utils</span><span style="color:#A6ACCD;">         </span><span style="color:#C3E88D;">-</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">外部工具目录</span></span>
<span class="line"><span style="color:#FFCB6B;">│</span><span style="color:#A6ACCD;">  </span><span style="color:#C3E88D;">│</span><span style="color:#A6ACCD;">  </span><span style="color:#C3E88D;">├─</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">assets.ts</span><span style="color:#A6ACCD;">  </span><span style="color:#C3E88D;">-</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">静态资源管理，所有静态资源都必须通过它来管理访问</span></span>
<span class="line"><span style="color:#FFCB6B;">│</span><span style="color:#A6ACCD;">  </span><span style="color:#C3E88D;">│</span><span style="color:#A6ACCD;">  </span><span style="color:#C3E88D;">├─</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">hooks</span><span style="color:#A6ACCD;">      </span><span style="color:#C3E88D;">-</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">hooks目录</span></span>
<span class="line"><span style="color:#FFCB6B;">│</span><span style="color:#A6ACCD;">  </span><span style="color:#C3E88D;">│</span><span style="color:#A6ACCD;">  </span><span style="color:#C3E88D;">├─</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">directive</span><span style="color:#A6ACCD;">  </span><span style="color:#C3E88D;">-</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">自定义指令目录</span></span>
<span class="line"><span style="color:#FFCB6B;">│</span><span style="color:#A6ACCD;">  </span><span style="color:#C3E88D;">│</span><span style="color:#A6ACCD;">  </span><span style="color:#C3E88D;">├─</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">init.ts</span><span style="color:#A6ACCD;">    </span><span style="color:#C3E88D;">-</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">初始化项目的脚本</span></span>
<span class="line"><span style="color:#FFCB6B;">│</span><span style="color:#A6ACCD;">  </span><span style="color:#C3E88D;">│</span><span style="color:#A6ACCD;">  </span><span style="color:#C3E88D;">├─</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">request.ts</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">-</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">基于Fetch</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">API封装的请求文件，所有API都会基于这个封装文件来进行</span></span>
<span class="line"><span style="color:#FFCB6B;">│</span><span style="color:#A6ACCD;">  </span><span style="color:#C3E88D;">│</span><span style="color:#A6ACCD;">  </span><span style="color:#C3E88D;">├─</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">router.ts</span><span style="color:#A6ACCD;">  </span><span style="color:#C3E88D;">-</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">路由配置文件</span></span>
<span class="line"><span style="color:#FFCB6B;">│</span><span style="color:#A6ACCD;">  </span><span style="color:#C3E88D;">│</span><span style="color:#A6ACCD;">  </span><span style="color:#C3E88D;">├─</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">storage.ts</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">-</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">本地缓存管理</span></span>
<span class="line"><span style="color:#FFCB6B;">│</span><span style="color:#A6ACCD;">  </span><span style="color:#C3E88D;">│</span><span style="color:#A6ACCD;">  </span><span style="color:#C3E88D;">├─</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">stores</span><span style="color:#A6ACCD;">     </span><span style="color:#C3E88D;">-</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">全局状态库目录</span></span>
<span class="line"><span style="color:#FFCB6B;">│</span><span style="color:#A6ACCD;">  </span><span style="color:#C3E88D;">│</span><span style="color:#A6ACCD;">  </span><span style="color:#C3E88D;">└─</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">tools.ts</span><span style="color:#A6ACCD;">   </span><span style="color:#C3E88D;">-</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">工具方法，包含一个非常常用的工具对象：cc</span></span>
<span class="line"><span style="color:#FFCB6B;">│</span><span style="color:#A6ACCD;">  </span><span style="color:#C3E88D;">└─</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">views</span><span style="color:#A6ACCD;">         </span><span style="color:#C3E88D;">-</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">页面目录，编写业务代码基本集中在这里</span></span>
<span class="line"><span style="color:#FFCB6B;">└─</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">vite.config.ts</span><span style="color:#A6ACCD;">   </span><span style="color:#C3E88D;">-</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">Vite配置文件</span></span></code></pre></div><h2 id="静态资源" tabindex="-1">静态资源 <a class="header-anchor" href="#静态资源" aria-label="Permalink to &quot;静态资源&quot;">​</a></h2><p>核心要义：所有在Vue组件中出现的静态图像资源，都必须放置在 <code>src/assets/images</code> 下，并且都必须要经过 <code>src/utils/assets.ts</code> 文件的控制来访问。<code>assets.ts</code> 管理静态资源的核心是基于Vite的静态资源处理能力，将静态资源的路径作为字符串引入（<code>import</code>），于是你可以看到 <code>assets.ts</code> 中有这样的代码：</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> vue </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">@/assets/images/vue.svg</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> scnuLogo </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">@/assets/images/scnu-logo.png</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> notFound </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">@/assets/images/notFound.png</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> internalError </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">@/assets/images/internal-error.svg</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">/** </span><span style="color:#89DDFF;font-style:italic;">@</span><span style="color:#C792EA;font-style:italic;">module</span><span style="color:#676E95;font-style:italic;"> </span><span style="color:#FFCB6B;font-style:italic;">所有的静态图形资源都应该通过这里引用</span><span style="color:#676E95;font-style:italic;"> */</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> assets </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    vue</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    scnuLogo</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    notFound</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    internalError</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>而在需要用到静态资源的地方（例如HTML中的 <code>&lt;img/&gt;</code> 标签）就可以这样引用：</p><div class="language-vue"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">img</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">:</span><span style="color:#C792EA;">src</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">assets</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">scnuLogo</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">/&gt;</span></span></code></pre></div><p>采用 <code>assets.ts</code> 统一管理的方式，首先能获得TS的代码提示支持，引入图像时根据语义可以快速定位图像，同时又能避免因为生产环境下根路径（<code>base</code>）的改变带来的副作用（如找不到图像等等）。</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>只有在 <code>index.html</code> 中唯一一次用到的静态文件，就建议放置在 <code>public</code> 目录中，因为只有受到Vue控制的模块才能享受 <code>assets.ts</code> 带来的静态资源管理能力。而目前来说，仅仅只有 <code>favicon</code> 需要这样处理，故你只能在 <code>public</code> 目录看到一张图片。</p></div><h2 id="工具方法" tabindex="-1">工具方法 <a class="header-anchor" href="#工具方法" aria-label="Permalink to &quot;工具方法&quot;">​</a></h2><p>CC已经对几乎所有常用基础功能进行了代码封装，并且被集成到了 <code>src/utils/tools.ts</code> 文件中，其导出一个名为 <code>cc</code> 的对象。</p><p>目前，<code>cc</code> 已经包含了：页面切换、全局交互、选择本地文件等基础模块。你将在<a href="/cc-tools.html">CC Tools 文档</a>中看到该工具对象的具体用法和介绍。</p><h2 id="本地缓存" tabindex="-1">本地缓存 <a class="header-anchor" href="#本地缓存" aria-label="Permalink to &quot;本地缓存&quot;">​</a></h2><p>CC也针对本地缓存封装了一套API，CC遵循<strong>任何缓存都必须经过JSON序列化</strong>的原则，<code>src/utils/storage.ts</code> 提供了这样的一套API。你只需要知道：</p><ul><li><code>storage.set</code> 往缓存里丢东西</li><li><code>storage.get</code> 往缓存里拿东西</li></ul><p>其中JSON序列化、反序列化的过程已经被封装好。如果报错，说明操作了不支持JSON序列化的数据。只要从头到尾对本地缓存的操作都采用这个API，那么这个报错几乎不可能出现。</p><div class="tip custom-block"><p class="custom-block-title">💡最佳实践</p><p>在使用 <code>storage.set</code> 时需要传入缓存键名，最佳方法不是时时刻刻硬编码写入，而是引用 <code>config.ts</code> 中 <code>storage</code> 的相应配置，你将在紧接着这一小节看到 <code>config.ts</code> 的介绍。</p></div><h2 id="全局配置" tabindex="-1">全局配置 <a class="header-anchor" href="#全局配置" aria-label="Permalink to &quot;全局配置&quot;">​</a></h2><p><code>src/config.ts</code> 存放了静态全局配置，静态意味着这些配置在运行过程中不应该被动态改变，故应该是<strong>只读</strong>的。</p><p>其中：</p><ul><li><p><code>app</code> 包含了应用配置，有WAP端的TabBar高度、PC端的Menu宽度、API前缀、根路径、PC端基准屏宽、默认标题栏标题、应用描述等等信息。</p></li><li><p><code>color</code> 包含了全局颜色配置，有意思的是CC在初始化时会将 <code>color</code> 中定义的颜色全部嵌入HTML的 <code>&lt;body&gt;&lt;/body&gt;</code> 中，采用了CSS变量的方法，于是你可以在任何Vue组件中使用CSS引用这些颜色，它们的命名规则是：</p><div class="language-css"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">--GLOBAL-$</span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;">config.color定义的颜色名，下划线改为中划线</span><span style="color:#89DDFF;">}</span></span></code></pre></div><p>例如：</p><div class="language-css"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">.</span><span style="color:#FFCB6B;">root</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#B2CCD6;">color</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">var</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">--GLOBAL-DARK-GREY</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">}</span></span></code></pre></div><p>这将让 <code>.root</code> 的元素文本颜色变为 <code>config.ts</code> 中定义的 <code>DARK_GREY</code> 的颜色</p><p>然而，如果你使用的是 <code>SCSS</code>, 我们有更加好的最佳实践：利用SCSS变量，变量命名与 <code>config.ts</code> 中的命名一致，例如：</p><div class="language-scss"><button title="Copy Code" class="copy"></button><span class="lang">scss</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">.</span><span style="color:#FFCB6B;">root</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#B2CCD6;">color</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> $DARK_GREY</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>你可以在 <code>src/assets/styles/global.scss</code> 中看到所有的全局SCSS变量定义。</p></li><li><p><code>storage</code> 包含了本地缓存的键名配置，也就是说在使用本地缓存时，你应该将键名都定义在这，而别处都应该从这里引用。</p></li></ul><h2 id="深入路由管理" tabindex="-1">深入路由管理 <a class="header-anchor" href="#深入路由管理" aria-label="Permalink to &quot;深入路由管理&quot;">​</a></h2><p>CC的路由管理上很大程度上依赖于Vite提供的模块懒加载能力，其中 <code>i<wbr>mport.meta.glob</code> 的用法可以参见<a href="https://vitejs.cn/vite3-cn/guide/features.html#glob-import" target="_blank" rel="noreferrer">Vite官方文档</a>对此的描述。</p><p>CC一共有三种路由：</p><ol><li>特殊的白名单路由：可以显式地指定匹配路径、匹配组件、meta等等</li><li>Tab路由：由 <code>src/tab.ts</code> 配置决定的路由，其命中路径会加上 <code>/t</code> 的前缀，匹配的组件在 <code>tab.ts</code> 中显式指定，同时还应指定该Tab栏的描述文字、装饰图标。</li><li>Stack路由：只要是在 <code>src/view/</code> 中任意非顶级目录下的 <code>index.vue</code>，都会被当作是一个Stack页面被路由到，并且前缀会自动加上 <code>/s</code>，比如：</li></ol><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">/s/guide/</span><span style="color:#A6ACCD;"> =</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">路由到</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">src/views/guide/index.vue</span></span>
<span class="line"><span style="color:#FFCB6B;">/s/record/detail/</span><span style="color:#A6ACCD;"> =</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">路由到</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">src/views/record/detail/index.vue</span></span></code></pre></div><p>也就是说，Stack路由的物理组件文件结构决定了其路由地址，所以你应该将 <code>index.vue</code> 作为且仅作为某一级页面的入口。</p><p>值得注意的是，Tab页在物理组件文件结构上也存在于 <code>src/views</code> 中，但是其在路由匹配中会被排除在Stack路由的匹配环节外。所以为了区分，现在Tab页都存在于 <code>src/views/tab</code> 的子目录下。但是，即使你改变这种约定，在 <code>tab.ts</code> 中配置的组件都不会被Stack路由找到！</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>你可以这么想象Tab页面和Stack页面：</p><ul><li><p>Tab页面相当于一打开微信就能看到的页面及其底栏。</p></li><li><p>Stack页面相当于聊天界面、朋友圈详情等没有底栏但是顶部有返回键的界面。</p></li></ul><p>如果你熟悉微信小程序，那么Tab页和Stack页和他的概念几乎一致。</p></div><h3 id="一级路由" tabindex="-1">一级路由 <a class="header-anchor" href="#一级路由" aria-label="Permalink to &quot;一级路由&quot;">​</a></h3><p>当页面开始加载时，首先会进入 <code>App.vue</code> 中，而 <code>App.vue</code> 会委托VueRouter来加载用户访问的目标页面，有三种情况：</p><ol><li>命中特殊白名单路由：返回白名单路由中显式指定的views，如 <code>/login</code></li><li>命中前缀是 <code>/t</code>：返回 <code>layouts/tab/index.vue</code></li><li>命中前缀是 <code>/s</code>：返回 <code>layouts/stack/index.vue</code></li><li>啥也不命中：返回 <code>layouts/not-found/index.vue</code> （缺省页）作为404页面。</li></ol><div class="warning custom-block"><p class="custom-block-title">注意</p><p>在这个一级路由中，要么返回特殊路由的组件直接作为页面（不受响应式layouts的控制），要么返回Stack的响应式layouts或Tab的响应式layouts（相当于其渲染模板）</p></div><p>假设路由命中了Stack路由或Tab路由，则会将路由任务交给<strong>二级路由</strong>，也就是你能在 <code>layouts/tab/index.vue</code> 中或 <code>layouts/stack/index.vue</code> 中看到的又一层 <code>router-view</code></p><h3 id="二级路由" tabindex="-1">二级路由 <a class="header-anchor" href="#二级路由" aria-label="Permalink to &quot;二级路由&quot;">​</a></h3><p>委托Stack路由或Tab路由进行查找，过程和一级路由差不多，但是所有的查找结果，都会被渲染在 <code>layouts</code> 相应目录下指定的模板中，比如Tab页面会被加上底部TabBar，Stack页面会被加上顶部标题栏和返回键。这一操作保证了所有页面的顶级交互（切换和返回）统一。</p><p>Stack模板的顶栏： <img src="`+o+'" alt="Alt text"></p><p>Tab模板的WAP端TabBar： <img src="'+p+'" alt="Alt text"></p><p>Tab模板的PC端Menu： <img src="'+e+`" alt="Alt text"></p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>特殊路由指定的页面不会被 <code>layouts</code> 的模板包裹，所以不应该滥用特殊路由，目前来看，只有类似 <code>/login</code> 这样的非正式业务内容的模块才应该被放在特殊路由中。</p></div><h2 id="深入响应式布局" tabindex="-1">深入响应式布局 <a class="header-anchor" href="#深入响应式布局" aria-label="Permalink to &quot;深入响应式布局&quot;">​</a></h2><h3 id="核心" tabindex="-1">核心 <a class="header-anchor" href="#核心" aria-label="Permalink to &quot;核心&quot;">​</a></h3><p>CC的样式布局核心是<strong>使用flex布局</strong>，如果你对flex布局不是那么熟悉，请先熟悉官方文档中对flex布局的描述：<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex" target="_blank" rel="noreferrer">MDN 文档 | Flex 布局</a></p><div class="danger custom-block"><p class="custom-block-title">DANGER</p><p>请注意，任何 <code>float</code> 布局是不被允许的！！</p></div><p>CC的双端响应式布局是借助<strong>flex布局</strong>和CSS中的<strong>媒体查询</strong>能力，以及在个别情况下借助TypeScript对屏幕宽度的变化监控来实现的。</p><h3 id="不同的布局入口" tabindex="-1">不同的布局入口 <a class="header-anchor" href="#不同的布局入口" aria-label="Permalink to &quot;不同的布局入口&quot;">​</a></h3><p>在上面<a href="#深入路由管理">深入路由管理</a>中已经介绍了Stack和Tab的两种布局模板，而Tab的布局模板中又有两种布局入口，因为在宽屏设备中，采用侧栏Menu会优于底部TabBar，而在窄屏设备中则又反过来。下面介绍Tab布局模板中的两种布局入口：</p><p>当用户进入页面时，TypeScript会实时更新用户的屏幕宽高信息，并存储在全局状态库中，你可以使用以下方式获取到当前屏幕的宽高状态：</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> system </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">useSystem</span><span style="color:#A6ACCD;">()</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> screen </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> system</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">screen</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// @param screen { width: number, height: number }</span></span></code></pre></div><p>如果是要判断是否为WAP端，可以直接访问该全局状态库的getter方法，如果屏幕宽度 <code>&lt;800px</code> 则会返回 <code>true</code>：</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> isWap </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> system</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">isWap</span></span></code></pre></div><ul><li>如果是WAP端，则会加载WAP的Tab模板（<code>src/layouts/tab/wap.vue</code>），也就是将路由匹配的组件渲染进WAP模板中。</li><li>如果是PC端，则会加载PC的Tab模板（<code>src/layouts/tab/pc.vue</code>），也就是将路由匹配的组件渲染进PC模板中。</li></ul><p>而模板文件只负责控制TabBar/Menu及其激活状态，也就是说，内部业务细节交给各自的views处理，而views也无需关心Menu或者TabBar是否正确显示了激活状态。</p><h3 id="views内的响应式" tabindex="-1">views内的响应式 <a class="header-anchor" href="#views内的响应式" aria-label="Permalink to &quot;views内的响应式&quot;">​</a></h3><p>在views内部，和layouts一样采用不同的Vue模板然后通过TS控制似乎不是一种很高效和友好的方式，CC更推荐在views的内部使用CSS的<strong>媒体查询</strong>功能来完成响应式布局。</p><p>比如，在WAP端，卡片适合采用纵向flex，而PC端卡片适合采用自动换行的横向flex，那么就可以在CSS/SCSS中利用变量这么写：</p><div class="language-scss"><button title="Copy Code" class="copy"></button><span class="lang">scss</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">.</span><span style="color:#FFCB6B;">card-wrapper</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#B2CCD6;">display</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> flex</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#B2CCD6;">justify-content</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> center</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#B2CCD6;">align-items</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> center</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#B2CCD6;">box-sizing</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> border-box</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#B2CCD6;">padding</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1rem</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#B2CCD6;">gap</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">.5rem</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;font-style:italic;">@media</span><span style="color:#A6ACCD;"> screen </span><span style="color:#89DDFF;">and</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#FFCB6B;">min-width</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> $PC_MIN_WIDTH</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#676E95;font-style:italic;">// PC端</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#B2CCD6;">flex-direction</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> row</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#B2CCD6;">flex-wrap</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> nowrap</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;font-style:italic;">@media</span><span style="color:#A6ACCD;"> screen </span><span style="color:#89DDFF;">and</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#FFCB6B;">max-width</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> $WAP_MAX_WIDTH</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#676E95;font-style:italic;">// WAP端</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#B2CCD6;">flex-direction</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> column</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>如果是CSS变量，那么上面的 <code>$PC_MIN_WIDTH</code> 和 <code>$WAP_MAX_WIDTH</code> 应该相应被替换成：</p><div class="language-css"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">@media</span><span style="color:#A6ACCD;"> screen </span><span style="color:#89DDFF;">and</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#FFCB6B;">min-width</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> var(--PC-MIN-WIDTH</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#676E95;font-style:italic;">/* ... */</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">@media</span><span style="color:#A6ACCD;"> screen </span><span style="color:#89DDFF;">and</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#FFCB6B;">max-width</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> var(--WAP-MAX-WIDTH</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#676E95;font-style:italic;">/* ... */</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><div class="tip custom-block"><p class="custom-block-title">💡最佳实践</p><p>如果一个views中有大量的布局需要应用到响应式，最好的方法是，在该views的根目录下的 <code>assets</code> 文件夹中创建 <code>index.wap.scss</code> 和 <code>index.pc.scss</code> 两个样式文件，然后分别书写两个端的样式，最后在组件中引入：</p><div class="language-vue"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">style</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">scoped</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">lang</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">scss</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">@import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">./assets/index.wap.scss</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">@import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">./assets/index.pc.scss</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">style</span><span style="color:#89DDFF;">&gt;</span></span></code></pre></div></div>`,91),r=[c];function C(y,i,D,A,d,F){return a(),n("div",null,r)}const g=s(t,[["render",C]]);export{h as __pageData,g as default};
